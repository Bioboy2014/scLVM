---
title: "An R wrapper for scLVM"
author: "Florian Buettner, Kedar N. Natarajan, F. Paolo Casale, Valentina Proserpio, Antonio Scialdone, Fabian J. Theis, Sarah A. Teichmann, John C. Marioni and Oliver Stegle"
#date: "7. Oktober 2014"
output: html_document
---
Stage 1: Fitting process
---

As scLVM was originally written in python, we recommend using the native python implementation as demonstrated in the tutorials and ipython notebooks on github.
However, we also provide an R wrapper. Note that this is not a native R implementation of scLVM, but calls the relevant python code from within R. That is why, in order to run scLVM-R, you need to install python 2.7 with scipy, h5py, numpy and pylab. It is particularly easy to install python using the anaconda python distribution. scLVM relies heavily on limix, which can be installed using pip install limix on most systems. In addition, you need to install the R package `rPython`. For details on installation and requirements, have a look at our  [github page](https://github.com/PMBio/scLVM/wiki/Installation).

In the following we assume you have python, R and all dependencies installed and run the code from the pre-processing notebook. 
First of all we need to load the rPython package and load the necessary variables into python. We can then initialise the scLVM model and fit the latent factor. Here, we fit the cell cycle factor. 

```{r}
library(rPython)
Y=t(LogNcountsMmus)
genes_het_bool = as.vector(genes_heterogen)
geneID = gene_names
tech_noise=as.vector(LogVar_techMmus)

set_data(Y=Y, tech_noise=tech_noise, genes_het_bool = genes_het_bool, geneID=geneID) 
idx_cell_cycle_noise_filtered = intersect(which(rowMeans(LogNcountsMmus)>0),c(unique(ccCBall_gene_indices,cellcyclegenes_filter))) #indices for cell cycle genes
init_scLVM(Y=Y, push_var = FALSE) #initialise sclvm model - we've loaded Y already so don't need to push it to python

k = 80                    # number of latent factors
out_dir = './cache'       # folder where results are cached
file_name = 'Kcc.hdf5'    # name of the cache file
recalc = TRUE             # recalculate X and Kconf
use_ard = TRUE            # use automatic relevance detection


idx = idx_cell_cycle_noise_filtered
gplvm_ard = fitGPLVM(idx=idx_cell_cycle_noise_filtered,k=k,out_dir=out_dir,file_name=file_name,recalc=recalc, use_ard=use_ard)
```


In order to establish the number of latent factors used to model the cell-cell covariance we plot the variance contributions of the individual latent factors.

```{r}
plot(seq(1, length(gplvm_ard$X_ard)), gplvm_ard$X_ard, xlab = '# Factor', ylab = 'Variance explained')
title('Variance explained by latent factors')
```

In our case there is a large gap between the first and the second factor which is why we only retain one latent factor. That is why we re-fit the GPLVM with one latent factor only.

```{r}
gplvm = fitGPLVM(idx=idx_cell_cycle_noise_filtered,k=1,out_dir=out_dir,file_name=file_name,recalc=TRUE, use_ard=FALSE)
```

Next, we plot the inferred cell-cell covarince matirx.

```{r}
#Plot inferred similarity matrix
Kcc = gplvm_ard$Kcc
image(Kcc,xaxt = "n", yaxt = "n", col = )
title('Similarity matrix based on cell cycle')
```

---
Stage 2: Variance decomposition and cell-cycle corection
---

We first perfrom a variance decomposition on the variable genes.

```{r}
# considers only heterogeneous genes
Ihet = which(genes_het_bool==1)
Y    = Y[,Ihet]
tech_noise = tech_noise[Ihet]
geneID = geneID[Ihet]

i0 = 1    # gene from which the analysis starts
i1 = 20   # gene at which the analysis ends

# define sclvm
init_scLVM(Y,geneID=geneID,tech_noise=tech_noise)

# fit the model from i0 to i1
varianceDecomposition(K=Kcc,i0=i0,i1=i1)
```

Once the contribution of cell cycle to the observed variance is estimated, cell-cycled corrected gene expression levels can be obtained. Variance components are normalised such that they sum uo to 1 and genes for which the variance decompostion has not convered are filtered out.

```{r}
normalize=TRUE    # variance components are normalizaed to sum up to one

# get variance components
results_var = getVarianceComponents(normalize=normalize)
var_filtered = results_var$var[results_var$conv,] # filter out genes for which vd has not converged
head(var_filtered)

# get corrected expression levels
Ycorr = getCorrectedExpression()
dim(Ycorr)

```
After having perfromed the variance decompostion we can illustrate the contributions of the indiviudal components.

```{r}
var_mean = apply(var_filtered,2,mean)
colors = c('Green','Blue','Gray')
pie(var_mean, , col = colors)
```

---
Correlation Analysis
---
In order to estimate pairwise correlation coefficients whilst controlling for hidden factors such as the cell cycle, we fit a linear mixed model with a fixed effect representing the contribution of another gene j and random effects representing the contribution of the cell cycle and biological variation.
Again, as computaion times can be very long we allow the computations to be split up over several calculations for subsets of genes.

```{r}
i0 = 1     # gene from which the analysis starts
i1 = 5    # gene at which the analysis ends

# fit lmm without correction
res_nocorr = fitLMM(K=None,i0=i0,i1=i1,verbose=TRUE, geneID = geneID)

# fit lmm with correction
res_corr = fitLMM(K=Kcc,i0=i0,i1=i1,verbose=TRUE, geneID = geneID)

```

Finally we can have a quick look at the difference between corrected and uncorrected correlations.

```{r}

heatmap.2(res_nocorr$beta[,i0:i1], Rowv = NULL, Colv = NULL, dendrogram = "none",
          labCol = as.character(seq(i0:i1)), labRow = as.character(seq(i0:i1)),srtCol = 0, key=T,density.info = "none",
          trace="none", breaks=seq.int(from = -0.6, to = 1.0, length.out = 13), main = 'Without Correction')

heatmap.2(res_corr$beta[,i0:i1], Rowv = NULL, Colv = NULL, dendrogram = "none",
          labCol = as.character(seq(i0:i1)), labRow = as.character(seq(i0:i1)),srtCol = 0, key=T,density.info = "none",
          trace="none", breaks=seq.int(from = -0.6, to = 1.0, length.out = 13), main = 'With Correction')
```
